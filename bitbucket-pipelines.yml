image: acidrain/python-poetry:3.7

ci-image: &ci-image
  name: "bsawsartifactory-docker.jfrog.io/st_sync-ci"
  username: "$PIPELINES_ARTIFACTORY_USERNAME"
  password: "$PIPELINES_ARTIFACTORY_TOKEN"

poetry_install: &poetry_install |-
  poetry config http-basic.artifactory "${PIPELINES_ARTIFACTORY_USERNAME}" "${PIPELINES_ARTIFACTORY_TOKEN}"
  poetry install

install_postgres_client: &install_postgres_client |-
  apt-get update
  apt-get install -y --no-install-recommends postgresql-client

step_fail_if_not_trunk: &step_fail_if_not_trunk
  name: Fail build if current branch is not trunk
  script:
    - ci-scripts/fail_if_not_trunk.sh

step_lint_unit_acceptance_tests: &step_lint_unit_acceptance_tests
  name: Lint, unit tests and mocked acceptance tests
  image: *ci-image
  caches:
    - pip
    - poetry
  script:
    - ci-scripts/check_linting.sh
    - ci-scripts/run_mocked_tests.sh
  after-script:
    - ci-scripts/manage_trunk_build_failure.sh

step_build_debian: &step_build_debian
  name: Build Debian package
  image:
    name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment
    aws:
      access-key: $AWS_ACCESS_KEY_ID
      secret-key: $AWS_SECRET_ACCESS_KEY
  script:
    - ci-scripts/build_debian_file.sh
  artifacts:
    - "*.deb"

step_build_docker_image: &step_build_docker_image
  name: Build Docker Image
  image: *ci-image
  caches:
    - docker
    - poetry
  services:
    - docker
  script:
    - ci-scripts/build_docker_image.sh st-sync*.deb
    - ci-scripts/run_service_locally.sh
    - ci-scripts/run_acceptance_tests.sh localhost
    - ci-scripts/upload_docker_image_to_repository.sh
  after-script:
    - ci-scripts/get_docker_logs.sh
  artifacts:
    - "*.log"

step_generate_helm_chart_from_compose: &step_generate_helm_chart_from_compose
  name: Generate Helm Chart from Docker Compose File
  image: *ci-image
  artifacts:
    - helm-chart/**
  script:
    - ci-scripts/create_helm_chart.sh
  after-script:
    - ci-scripts/manage_trunk_build_failure.sh

step_test_helm: &step_test_helm
  name: Test Helm Chart
  image: *ci-image
  artifacts:
    - st-sync-*.tgz
  services:
    - docker
  script:
    - ci-scripts/deploy_helm_chart.sh
    - ci-scripts/test_helm_chart.sh
  after-script:
    - ci-scripts/delete_kubernetes_namespace.sh
    - ci-scripts/delete_docker_image_from_repository_if_not_trunk.sh
    - ci-scripts/manage_trunk_build_failure.sh

step_tag_commit_as_good_build: &step_tag_commit_as_good_build
  name: Tag commit as good build
  script:
    - ./ci-scripts/fail_if_not_trunk.sh
    - ./ci-scripts/tag_commit_as_good_build.sh

step_tag_docker_image_as_latest: &step_tag_docker_image_as_latest
  name: Tag docker image as latest
  script:
    - ./ci-scripts/fail_if_not_trunk.sh
    - ./ci-scripts/tag_docker_image_as_latest.sh

step_upload_helm_chart_to_repository: &step_upload_helm_chart_to_repository
  name: Upload helm chart to repository
  script:
    - ./ci-scripts/fail_if_not_trunk.sh
    - . ./ci-scripts/load_project_name.sh
    - . ./ci-scripts/load_helm_package_name.sh
    - pipe: docker://bsawsartifactory-docker-bitbucket-pipes-local.jfrog.io/artifactory-upload-pipe:latest
      variables:
        ARTIFACTORY_URL: "${ARTIFACTORY_URL}"
        ARTIFACTORY_ACCESS_TOKEN: "${PIPELINES_ARTIFACTORY_TOKEN}"
        SOURCE_PATTERN: "${HELM_PACKAGE_NAME}"
        TARGET_PATTERN: "helm-local/${PROJECT_NAME}/${HELM_PACKAGE_NAME}"
        BUILD_NAME: "helm-${PROJECT_NAME}"

pipelines:
  branches:
    task/**:
      - parallel:
        - step:
            name: Linting
            caches:
              - pip
            script:
              - ci-scripts/check_linting.sh
        - step: &unittests
            name: Unit tests
            image:
              name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_functional_tests_ci_environment:poetry
              aws:
                access-key: $AWS_ACCESS_KEY_ID
                secret-key: $AWS_SECRET_ACCESS_KEY
            caches:
              - poetry
            script:
              - ci-scripts/run_mocked_tests.sh
        - step:
            name: Communication Tests
            caches:
              - poetry
              - docker
            image:
              name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_functional_tests_ci_environment:poetry
              aws:
                access-key: $AWS_ACCESS_KEY_ID
                secret-key: $AWS_SECRET_ACCESS_KEY
            script:
              - *poetry_install
              - docker pull mdillon/postgis:9.6
              - poetry run python run.py comm_tests
            services:
              - docker

    feature/**:
      - step: &functionaltests
          name: Functional Tests
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_functional_tests_ci_environment:poetry
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          caches:
            - poetry
          script:
            - *poetry_install
            - mv st_sync/default_test_settings.py st_sync/test_settings.py
            - poetry run alembic -x test upgrade head
            - poetry run behave functional_test --verbose --logging-level WARNING
          services:
            - postgres
            - redis

    integration:
      - step: *step_fail_if_not_trunk
      - parallel:
          - step: *step_lint_unit_acceptance_tests
          - step: *step_build_debian
      - step:
          name: Upload debian package to s3
          script:
            - deb_file="st_sync_${BITBUCKET_BRANCH}_latest.deb"
            - mv "$(ls *.deb)" "${deb_file}"
            - s3cmd --access_key="${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST}" --secret_key="${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST}" put "${deb_file}" s3://serv-direct-st/deployment/st_sync/
      - step: *step_build_docker_image
      - step: *step_generate_helm_chart_from_compose
      - step: *step_test_helm
      - parallel:
          - step: *step_tag_commit_as_good_build
          - step: *step_tag_docker_image_as_latest
          - step: *step_upload_helm_chart_to_repository

    tbd/**:  # Trunk Based Dev
      - parallel:
        - step: *step_lint_unit_acceptance_tests
        - step: *step_build_debian
      - step: *step_build_docker_image
      - step: *step_generate_helm_chart_from_compose
      - step: *step_test_helm

  custom:
    test:
      - step:
          name: Test
          script:
            - echo "Test"
            - echo "Current branch is '${BITBUCKET_BRANCH}'"
            - if [ "$BITBUCKET_BRANCH" = "integration" ]; then
            -    echo "INTEGRATION"
            - else
            -    echo "NOT INTEGRATION"
            - fi
            - exit 69
      - step:
          name: Test2
          script:
            - echo "THIS SHOULD NOT HAPPEN"

    run_system_tests:
      - step:
          name: Build Deb Package
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          artifacts:
            - persist_env_vars_direct_build_debian.sh
          script:
            - utils/scripts/debian_build.sh
            - cd ..
            - export DEB_PACKAGE="$(ls *.deb)"
            - s3cmd --access_key=${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST} --secret_key=${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST} put $DEB_PACKAGE s3://serv-direct-st/DAG/st_sync/
            - echo "export ST_SYNC_DEBIAN_URL=s3://serv-direct-st/DAG/st_sync/${DEB_PACKAGE}" >> ${BITBUCKET_CLONE_DIR}/persist_env_vars_direct_build_debian.sh
      - step:
          name: System Tests
          image: python:latest
          max-time: 120
          caches:
            - pip
          script:
            - . persist_env_vars_direct_build_debian.sh
            - export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID_CI_INTEGRATION_TESTS_FIXTURES_CREATION_USER}"
            - export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY_CI_INTEGRATION_TESTS_FIXTURES_CREATION_USER}"
            - export AWS_DEFAULT_REGION=${AWS_REGION_INTEGRATION_TESTS}
            - export SHARED_SERVICE_KEY="${AWS_ACCESS_KEY_ID_R53}"
            - export SHARED_SERVICE_SECRET="${AWS_SECRET_ACCESS_KEY_R53}"
            - export S3_AWS_ACCESS_KEY_ID="${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST}"
            - export S3_AWS_SECRET_ACCESS_KEY="${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST}"
            - pip install direct-system-tests -i https://${PYPI_ARTIFACTORY_READONLY_USERNAME}:${PYPI_ARTIFACTORY_READONLY_TOKEN}@${ARTIFACTORY_PYPI_URL}
            - direct-system-tests --junit --junit-directory ./test-reports

    Deploy to QA Air Test server:
      - step:
          name: Deploy to Core Direct
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          caches:
            - node
          script:
            - utils/scripts/debian_build.sh
            - cd ..
            - export DEB_PACKAGE="$(ls *.deb)"
            - scp $DEB_PACKAGE ${QA_SERVER_USER}@${CORE_DIRECT_SERVER}:${QA_DEB_PACKAGE_LOCATION}
            - cd -
            - ssh ${QA_SERVER_USER}@${CORE_DIRECT_SERVER} -C "sudo dpkg -i ${QA_DEB_PACKAGE_LOCATION}/${DEB_PACKAGE} && source ${QA_VENV_LOCATION}/bin/activate && cd ${QA_PROJECT_ROOT_LOCATION} && alembic upgrade head && deactivate && sudo supervisorctl stop st_sync:* && sudo supervisorctl update && sudo supervisorctl start st_sync:* && rm -f ${QA_DEB_PACKAGE_LOCATION}/${DEB_PACKAGE}"
            - utils/scripts/deployment_notify_slack.sh ${CORE_DIRECT_SERVER}

    Deploy to QA Server 01:
      - step: &qa-deploy
          name: Deploy to QA Server 01
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          caches:
            - node
          script:
            - &debian-build
              utils/scripts/debian_build.sh
            - export QA_SERVER=${QA_SERVER_01_HOST}
            - &deploy
              utils/scripts/deploy_to_qa_server.sh ${QA_SERVER}
              utils/scripts/deployment_notify_slack.sh ${QA_SERVER}

    Deploy to QA Server 02:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 02
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_02_HOST}
            - *deploy

    Deploy to QA Server 03:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 03
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_03_HOST}
            - *deploy

    Deploy to QA Server 04:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 04
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_04_HOST}
            - *deploy

    Deploy to QA Server 05:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 05
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_05_HOST}
            - *deploy

    Deploy to QA Server 06:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 06
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_06_HOST}
            - *deploy

    Deploy to QA Server 07:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 07
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_07_HOST}
            - *deploy

    Deploy to QA Server 08:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 08
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_08_HOST}
            - *deploy

    Deploy to QA Server 09:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 09
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_09_HOST}
            - *deploy

    Deploy to QA Server 10:
      - step:
          <<: *qa-deploy
          name: Deploy to QA Server 10
          script:
            - *debian-build
            - export QA_SERVER=${QA_SERVER_10_HOST}
            - *deploy

    Build Debian package:
      - step:
          name: Build Deb Package
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          script:
            - utils/scripts/debian_build.sh
            - cd ..
            - export DEB_PACKAGE="$(ls *.deb)"
            - s3cmd --access_key=${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST} --secret_key=${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST} put $DEB_PACKAGE s3://serv-direct-st/master_qa/st_sync/

    Build Latest Debian:
      - step:
          name: Build Latest Deb Package
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          script:
            - if [ "${BITBUCKET_BRANCH}" = "integration" ]; then
            - utils/scripts/debian_build.sh
            - cd ..
            - export DEB_PACKAGE="$(ls *.deb)"
            - mv ${DEB_PACKAGE} st_sync_${BITBUCKET_BRANCH}_latest.deb
            - s3cmd --access_key=${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST} --secret_key=${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST} put st_sync_${BITBUCKET_BRANCH}_latest.deb s3://serv-direct-st/deployment/st_sync/
            - else
            - echo build branch latest currently supports only the integration branch
            - fi

    Deploy to integration:
      - step: *unittests
      - step: *functionaltests
      - step:
          name: Build Deb Package
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_debian_packaging_ci_environment:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          script:
            - utils/scripts/debian_build.sh
            - cd ..
            - export DEB_PACKAGE="$(ls *.deb)"
            - s3cmd --access_key=${S3_AWS_ACCESS_KEY_ID_SERV_DIRECT_ST} --secret_key=${S3_AWS_SECRET_ACCESS_KEY_SERV_DIRECT_ST} put ${DEB_PACKAGE} s3://serv-direct-st-sync/${BITBUCKET_BRANCH}/
            - cp *.deb ${BITBUCKET_CLONE_DIR}/sync.deb
          artifacts:
            - sync.deb
      - step:
          name: Deploy to Integration
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/direct-clusterbuilder:latest
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          script:
            - export AWS_ACCESS_KEY_ID=${IN_ACCESS_KEY_ID}
            - export AWS_SECRET_ACCESS_KEY=${IN_SECRET_ACCESS_KEY}
            - utils/scripts/get_ips.sh ${BITBUCKET_CLONE_DIR}
            - utils/scripts/deploy_multinode.sh $(cat app_node0) $(cat app_node1) $(cat bastion)

    Run Functional Tests:
      - step: *functionaltests

    Build CI Image:
      - step:
          name: Build CI Image
          image: atlassian/default-image:2
          services:
            - docker
          script:
            - . ./ci-scripts/load_docker_repository_credentials.sh

            - image_name="${DOCKER_REPOSITORY}/${BITBUCKET_REPO_SLUG}-ci"
            - pip_index_url="https://${PYPI_ARTIFACTORY_READONLY_USERNAME}:${PYPI_ARTIFACTORY_READONLY_TOKEN}@${ARTIFACTORY_PYPI_URL}"
            - docker build --no-cache -t "${image_name}" --build-arg PIP_INDEX_URL="${pip_index_url}" - < ci-scripts/Dockerfile

            - docker login "${DOCKER_REPOSITORY}" --username "${DOCKER_REPOSITORY_USERNAME}" --password "${DOCKER_REPOSITORY_API_KEY}"
            - docker push "${image_name}"

    Build Test Database Image:
      - step:
          name: Build image and send to artifactory
          image:
            name: 852638264781.dkr.ecr.ca-central-1.amazonaws.com/st_functional_tests_ci_environment:poetry
            aws:
              access-key: $AWS_ACCESS_KEY_ID
              secret-key: $AWS_SECRET_ACCESS_KEY
          caches:
            - docker
            - poetry
          services:
            - docker
          script:
            - export PG_CONN_STR="postgresql://postgres:postgres@localhost/st_sync"
            - export DOCKER_IMAGE_NAME="st-sync-test-database"

            - docker run --rm --detach -p 5432:5432 -e "POSTGRES_HOST_AUTH_METHOD=trust" -v "$(pwd)/ci-scripts/st-sync-test-database/init.sql:/docker-entrypoint-initdb.d/init.sql" postgis/postgis:9.6-2.5

            - *poetry_install
            - *install_postgres_client

            - echo "PG_CONN_STR = '${PG_CONN_STR}'" > st_sync/settings.py

            - poetry run alembic upgrade head

            - cd ci-scripts/st-sync-test-database
            - pg_dumpall -h localhost -U postgres --roles-only | grep -v 'ROLE postgres' > roles.sql
            - pg_dump -U postgres -h localhost --schema-only -d st_sync > schema.sql

            - docker build -t "${ARTIFACTORY_DOCKER_REPO}/${DOCKER_IMAGE_NAME}" .
            - docker login "${ARTIFACTORY_DOCKER_REPO}" --username "${PIPELINES_ARTIFACTORY_USERNAME}" --password "${PIPELINES_ARTIFACTORY_TOKEN}"
            - docker push "${ARTIFACTORY_DOCKER_REPO}/${DOCKER_IMAGE_NAME}:latest"

definitions:
  services:
    docker:
      memory: 3072
    postgres:
      image: mdillon/postgis:9.6
      environment:
        POSTGRES_DB: 'a_db'
        POSTGRES_USER: 'a_db_user'
        POSTGRES_PASSWORD: 'a_password'
    redis:
      image: redis:4.0.8
  caches:
    poetry: ~/.cache/pypoetry
